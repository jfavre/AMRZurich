// ************************************************************************* //
//                            avtAMAZEFileFormat.C                           //
// ************************************************************************* //

#include <avtAMAZEFileFormat.h>

#include <string>
#include <vtkAMRAmazeReaderInternal.h>
#include <vtkFieldData.h>
#include <vtkDataArray.h>
#include <vtkDoubleArray.h>
#include <vtkDataSetWriter.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkPolyData.h>
#include <vtkPointData.h>
#include <InvalidDBTypeException.h>
#include <avtDatabaseMetaData.h>
#include <avtIntervalTree.h>
#include <avtResolutionSelection.h>
#include <avtStructuredDomainNesting.h>
#include <avtStructuredDomainBoundaries.h>
#include <avtVariableCache.h>
#include <avtDatabase.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>
#include <DBOptionsAttributes.h>
#include <DebugStream.h>
#include <InvalidVariableException.h>

using std::string;
using std::vector;
// ****************************************************************************
//  Method: avtAMAZEFileFormat constructor
//
//  Programmer: jfavre -- generated by xml2avt
//  Creation:   Fri Nov 6 10:10:36 PDT 2009
//
// ****************************************************************************

avtAMAZEFileFormat::avtAMAZEFileFormat(const char *filename, DBOptionsAttributes *readOpts)
    : avtSTMDFileFormat(&filename, 1)
{
  this->initializedReader = false;

  this->ReadShiftedGridInfo = false;
  this->ComputeLog10 = false;
  this->ApplyLengthScale = false;
  this->ScaleChoice = NoScale;

  if (readOpts != NULL)
    {
    for (int i = 0; i < readOpts->GetNumberOfOptions(); ++i)
      {
       if (readOpts->GetName(i) == "Compute Log10")
         {
         this->ComputeLog10 = readOpts->GetBool("Compute Log10");
         }
       else if (readOpts->GetName(i) == "Apply Length Scale Factor")
         {
         this->ApplyLengthScale = readOpts->GetBool("Apply Length Scale Factor");
         }
       else if (readOpts->GetName(i) == "Use Shifted Grid Info")
         {
         this->ReadShiftedGridInfo = readOpts->GetBool("Use Shifted Grid Info");
         }
       else if (readOpts->GetName(i) == "BoxLength")
         {
         this->ScaleChoice = (ScaleOption)readOpts->GetEnum("BoxLength");
         switch(this->ScaleChoice)
           {
           case 0: // pc
           debug1 << "!!!\nUsing PARSEC with Length Scale Factor * by 3.0857e18 = " << "\n";
           break;
           case 1: // AU
           debug1 << "!!!\nUsing AU with Length Scale Factor * by 1.49598e13 = "  << "\n";
           break;
           case 2: // RSun
           debug1 << "!!!\nUsing RSun with Length Scale Factor * by 6.960e10 = " << "\n";
           break;
           case 3:
           debug1 << "!!!\nLength Scale Factor  is untouched!!!\n";
           break;
           }
         }
       else
         debug1 << "Ignoring unknown option " << readOpts->GetName(i) << endl;
      }
  }
}

void
avtAMAZEFileFormat::ActivateTimestep()
{
  this->InitializeReader();
}

void avtAMAZEFileFormat::InitializeReader(void)
{
  if(!this->initializedReader)
   {
   //cerr << "104: myreader->New()" << endl;
   this->myreader = vtkAMRAmazeReaderInternal::New();
   if(this->myreader == NULL)
     {
     EXCEPTION1(InvalidDBTypeException, "The file could not be opened");
     }

  if(this->ComputeLog10)
    {
    this->myreader->LogDataOn();
    }
  else
    {
    this->myreader->LogDataOff();
    }

  if(this->ApplyLengthScale)
    this->myreader->LengthScaleOn();
  else
    this->myreader->LengthScaleOff();


  this->myreader->SetScaleChoice(this->ScaleChoice);

  this->myreader->SetFileName((char*)GetFilename());

  this->myreader->ReadMetaData();

  this->initializedReader = true;
  }
  return;
}

// ****************************************************************************
//  Method: avtAMAZEFileFormat::FreeUpResources
//
//  Purpose:gui2.1.0
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: jfavre -- generated by xml2avt
//  Creation:   Fri Nov 6 10:10:36 PDT 2009
//
// ****************************************************************************

void
avtAMAZEFileFormat::FreeUpResources(void)
{
  initializedReader = false;

  if(this->myreader!=NULL)
    {
    //cerr << "151: myreader->Delete()\n";
    this->myreader->Delete();
    this->myreader = NULL;
  }
}

double avtAMAZEFileFormat::GetTime(void)
{
  this->InitializeReader();
  debug1 << "AMAZE::GetTime(): " << this->myreader->GetTime() << endl;
  return this->myreader->GetTime();
}


// ****************************************************************************
//  Method: avtAMAZEFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: jfavre -- generated by xml2avt
//  Creation:   Fri Nov 6 10:10:36 PDT 2009
//
// ****************************************************************************

void
avtAMAZEFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
  if (!this->initializedReader)
     this->InitializeReader();

  if(this->ReadShiftedGridInfo)
    {
    cerr << "Shifting the grid info\n";
    this->myreader->ReadHDF5GridsMetaData(true);
    }
  if (!avtDatabase::OnlyServeUpMetaData())
    {
    this->CalculateDomainNesting();
    //cerr << this->myreader->GetFileName() << ": PopulateDatabaseMetaData()\n";
    }
  else
    {
    //cerr << this->myreader->GetFileName() << ": PopulateDatabaseMetaData(MetaData Only)\n";
    }
  this->myreader->BuildStars();

  int totalPatches = this->myreader->GetNumberOfGrids();
  avtMeshMetaData *mesh = new avtMeshMetaData;
  avtCentering centering = AVT_NODECENT;

  if(this->myreader->GetCellCentered())
    {
    centering = AVT_ZONECENT;
    cerr << "found zone-centered data\n";
    }
  mesh->name = "mesh";
  mesh->originalName = "mesh";
  mesh->meshType = AVT_AMR_MESH;
  mesh->topologicalDimension = this->myreader->GetDimensionality();
  mesh->spatialDimension =  mesh->topologicalDimension;
  mesh->blockOrigin = 0;
  mesh->groupOrigin = 0;
  switch(this->myreader->GetScaleChoice())
    {
    case 0: // pc
     mesh->xUnits = "parsec";
     mesh->yUnits = "parsec";
     mesh->zUnits = "parsec";
    break;
    case 1: // AU
     mesh->xUnits = "AU";
     mesh->yUnits = "AU";
     mesh->zUnits = "AU";
    break;
    case 2: // RSun
     mesh->xUnits = "RSun";
     mesh->yUnits = "RSun";
     mesh->zUnits = "RSun";
    break;
    case 3:
     mesh->xUnits = "cm";
     mesh->yUnits = "cm";
     mesh->zUnits = "cm";
    break;
    }

  mesh->xLabel = "x";
  mesh->yLabel = "y";
  mesh->zLabel = "z";

  mesh->numBlocks = totalPatches;
  mesh->blockTitle = "Patches";
  mesh->blockPieceName = "patch";
        // Level as group
  mesh->numGroups = this->myreader->GetNumberOfLevels();
  mesh->groupTitle = "Levels";
  mesh->groupPieceName = "level";

  vector<int> groupIds(totalPatches);
  vector<string> blockPieceNames(totalPatches);
  int levels_of_detail = 0;
  for (int i = 0 ; i < totalPatches ; i++)
    {
    char tmpName[128];
    int level, local_patch;
    this->myreader->FindLevelAndBlock(i, level, local_patch);
    groupIds[i] = level;
    levels_of_detail = std::max(levels_of_detail, level);
    sprintf(tmpName, "Grid %d", this->myreader->Grids[i].grid_nr);
    blockPieceNames[i] = tmpName;
    //cerr << "patch " << i << ", " << tmpName << " at level " << level << endl;
    }

  mesh->LODs = levels_of_detail;
  mesh->blockNames = blockPieceNames;
  this->resolution = levels_of_detail; // current acceptable res = max res
  md->Add(mesh);
  md->AddGroupInformation(this->myreader->GetNumberOfLevels(),
                          totalPatches,
                          groupIds);

  for(int i=0; i < this->myreader->NumberOfComponents; i++)
    {
    if(this->myreader->Labels[i].vec_len == 1)
      {
      debug1 << "adding scalar " << this->myreader->Labels[i].label << endl;
      AddScalarVarToMetaData(md, this->myreader->Labels[i].label, "mesh", centering);
      }
    else if(this->myreader->Labels[i].vec_len >= 2){
      debug1 << "adding vector " << this->myreader->Labels[i].label << " of size " << 3 << endl;
      AddVectorVarToMetaData(md, this->myreader->Labels[i].label, "mesh", centering, 3);
      }
    }

  int nbstars = this->myreader->NumberOfSphericallySymmetricStars + this->myreader->NumberOfAxisSymmetricStars;
  if(nbstars)
    {
// we add two more PolyData, which are spherical representations of stars
  //for(int i=0; i < this->myreader->NumberOfSphericallySymmetricStars; i++)

  avtMeshMetaData *stars = new avtMeshMetaData;
  stars->name = "Stars";

  stars->originalName = "Stars";
  stars->meshType = AVT_SURFACE_MESH;
  stars->topologicalDimension = 2;
  stars->spatialDimension = 3;
  stars->blockOrigin = 0;
  stars->numBlocks = nbstars;
  vector<string> starNames(stars->numBlocks);
  for(int i=0; i < nbstars; i++)
    {
    if(this->myreader->Stars[i]->GetFieldData())
       if(this->myreader->Stars[i]->GetFieldData()->GetArray(0))
         {
         starNames[i] = this->myreader->Stars[i]->GetFieldData()->GetArray(0)->GetName();
         debug5 << "VisIt adding " << starNames[i] << endl;
         }
    }
  stars->blockNames = starNames;
  md->Add(stars);

// prefix the variable's name by Star- for stars
  AddScalarVarToMetaData(md, "Star-Mass", "Stars", AVT_NODECENT);
  AddScalarVarToMetaData(md, "Star-Temperature", "Stars", AVT_NODECENT);
  AddScalarVarToMetaData(md, "Star-Luminosity", "Stars", AVT_NODECENT);

  AddVectorVarToMetaData(md, "Star-Velocity", mesh->name, AVT_NODECENT, 3);
  }
  debug1 << "exiting PopulateDatabaseMetaData()\n";
}


// ****************************************************************************
//  Method: avtAMAZEFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: jfavre -- generated by xml2avt
//  Creation:   Fri Nov 6 10:10:36 PDT 2009
//
// ****************************************************************************

vtkDataSet *
avtAMAZEFileFormat::GetMesh(int domain, const char *meshname)
{
  if(!strcmp(meshname, "mesh"))
    {
    if (!this->initializedReader)
        this->InitializeReader();
    //if(!domain)cerr << "AMAZE:getting (" <<domain<< ") " << *this->myreader << endl;
    switch (this->myreader->MappedGrids) {
      case NoMap:
        //cerr << "ReadRectilinearGrid("<<domain<<")\n";
        return this->myreader->ReadRectilinearGrid(domain);
      break;
      
      case Sphere_LogR:
      //cerr << "ReadStructuredGrid("<<domain<<")\n";
      return this->myreader->ReadStructuredGrid(domain);
      break;

      case DCR_Cart2Spheres:
      cerr << "ReadStructuredGrid2("<<domain<<")\n";
      return this->myreader->ReadStructuredGrid2(domain);
      break;
      }
    }
  else
    { // get the stars indexed by their names, as in "Wind", "Accretor", etc.
    vtkPolyData *pd = vtkPolyData::New();
    pd->ShallowCopy( this->myreader->GetStar(domain));
    //cerr << "meshname = " << meshname << endl << *pd << endl;
    return (vtkDataSet*)pd;
    }
}


// ****************************************************************************
//  Method: avtAMAZEFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: jfavre -- generated by xml2avt
//  Creation:   Fri Nov 6 10:10:36 PDT 2009
//
// ****************************************************************************

vtkDataArray *
avtAMAZEFileFormat::GetVar(int domain, const char *varname)
{
  //cerr << "GetVar(" << domain << ", " << varname << ")\n";
  if(strncmp(varname, "Star-", 5))
    return (vtkDataArray *)this->myreader->ReadVisItVar(domain, varname);
  else
    {
    cerr << "returning copy of StarsData[0]\n";
    //cerr << "found " << this->myreader->SpherSymStarsData.size() << " data arrys for stars\n";
    //vtkDoubleArray *da = static_cast<vtkDoubleArray *>(vtkDoubleArray::New());
    return this->myreader->GetStar(domain)->GetPointData()->GetArray(0);
    //return da;
    }
}

void
map_V_rtp2xyz(double R, double T, double P, double *xyz)
{
//cerr << " " << R << " " << T << " " << P << " => " << xyz[0] << " " << xyz[1] << " " << xyz[2] << endl;
  double t[2];
  t[0]=xyz[0];
  t[1]=xyz[1];

  xyz[0] = sin(T)*cos(P)*xyz[2] + cos(T)*cos(P)*t[1] - sin(P)*t[0] ;
  xyz[1] = sin(T)*sin(P)*xyz[2] + cos(T)*sin(P)*t[1] + cos(P)*t[0];
  xyz[2] = cos(T)*xyz[2] - sin(T)*t[1] ;

}

// ****************************************************************************
//  Method: avtAMAZEFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: jfavre -- generated by xml2avt
//  Creation:   Fri Nov 6 10:10:36 PDT 2009
//
// ****************************************************************************

vtkDataArray *
avtAMAZEFileFormat::GetVectorVar(int domain, const char *varname)
{
  vtkDataArray *vec = (vtkDataArray *)this->myreader->ReadVisItVar(domain, varname);
  return vec;
}

void *
avtAMAZEFileFormat::GetAuxiliaryData(const char *var, int dom, 
                                    const char * type, void *,
                                    DestructorFunction &df)
{
  double dx;
  int levelId, blockId;
  if (type != AUXILIARY_DATA_SPATIAL_EXTENTS)
    return NULL;
  if(this->myreader->MappedGrids)
    {
    return NULL;
    }
  else
    {

  int numGrids = this->myreader->GetNumberOfGrids();
  avtIntervalTree *itree = new avtIntervalTree(numGrids, 3);
//
// modified bounds[1], [3] and [5] to use calculated bounds instead of bounds read
// from file
  for (int grid = 0 ; grid < numGrids ; grid++)
    {
    double bounds[6];
    this->myreader->FindLevelAndBlock(grid, levelId, blockId);

    dx = this->myreader->Levels[levelId].DXs[0];
    bounds[0] = this->myreader->Grids[grid].origin[0];
    //bounds[1] = this->myreader->Grids[grid].origin[3];
    bounds[1] = bounds[0] + dx * (this->myreader->Grids[grid].dimensions[0]-1);

    dx = this->myreader->Levels[levelId].DXs[1];
    bounds[2] = this->myreader->Grids[grid].origin[1];
    //bounds[3] = this->myreader->Grids[grid].origin[4];
    bounds[3] = bounds[2] + dx * (this->myreader->Grids[grid].dimensions[1]-1);

    dx = this->myreader->Levels[levelId].DXs[2];
    bounds[4] = this->myreader->Grids[grid].origin[2];
    //bounds[5] = this->myreader->Grids[grid].origin[5];
    bounds[5] = bounds[4] + dx * (this->myreader->Grids[grid].dimensions[2]-1);
    if(this->myreader->GetLengthScale())
      {
      for (int p=0; p < 6; p++)
        {
        bounds[p] /= this->myreader->GetLengthScaleFactor();
        }
      }
//cerr << "Patc " << grid << ": " << bounds[0] << "," << bounds[1]<< ", " << bounds[2]<< "," << bounds[3]<< ", " << bounds[4]<< "," << bounds[5] << endl;
    itree->AddElement(grid, bounds);
    }
  itree->Calculate(true);

  df = avtIntervalTree::Destruct;

  return ((void *) itree);
  }
}

void
avtAMAZEFileFormat::CalculateDomainNesting(void)
{
  int child_level, child_patch, level, patch, my_level, local_patch;
  int nLevels =      this->myreader->GetNumberOfLevels();
  int totalPatches = this->myreader->GetNumberOfGrids();
  int dimension =    this->myreader->GetDimensionality();
  //cerr << "CalculateDomainNesting(" << nLevels << ", " << totalPatches << ")\n";
  avtStructuredDomainNesting *dn = new avtStructuredDomainNesting(totalPatches, nLevels);
  avtStructuredDomainBoundaries *rdb;
  if(this->myreader->MappedGrids)
    {
    cerr << "WITH MAPPED Grids\n";
    rdb = new avtCurvilinearDomainBoundaries(true);
    }
  else
    {
    rdb = new avtRectilinearDomainBoundaries(true);
    }
  dn->SetNumDimensions(dimension);

  vector<int> rr(dimension);

  int patchCount = 1;
  for (level = 0 ; level < nLevels ; level++)
    {
    if (level == 0)
      {
      rr[0] = rr[1] = 1;
      if(dimension == 3) rr[2] = 1;
      }
    else
      {
      rr[0] = rr[1] = this->myreader->Levels[level].RefRatio;
      if(dimension == 3) rr[2] = this->myreader->Levels[level].RefRatio;
      //cerr << "set refinement ratio of level " << level << " = " << rr[0] << endl;
      dn->SetLevelRefinementRatios(level, rr);  // ?? should be level, or level+1??
      }
    }
  rdb->SetNumDomains(totalPatches);
  for (patch = 0 ; patch < totalPatches ; patch++)
    {
    vector<int> childPatches;
    childPatches.clear();
    this->myreader->FindLevelAndBlock(patch, my_level, local_patch);
    //cerr << "#################\nPatch " << patch << " level " << my_level << ": ";

    vector<int> ParentExts(6), ChildExts(6);
    ParentExts[0] = this->myreader->Grids[patch].box_corners[0] * this->myreader->Levels[my_level+1].RefRatio;
    ParentExts[1] = this->myreader->Grids[patch].box_corners[1] * this->myreader->Levels[my_level+1].RefRatio;
    ParentExts[2] = this->myreader->Grids[patch].box_corners[2] * this->myreader->Levels[my_level+1].RefRatio;
    ParentExts[3] = this->myreader->Grids[patch].box_corners[3] * this->myreader->Levels[my_level+1].RefRatio;
    ParentExts[4] = this->myreader->Grids[patch].box_corners[4] * this->myreader->Levels[my_level+1].RefRatio;
    ParentExts[5] = this->myreader->Grids[patch].box_corners[5] * this->myreader->Levels[my_level+1].RefRatio;

    //cerr << ParentExts[0] << ", " << ParentExts[1] << ", " << ParentExts[2] << ", " << ParentExts[3] << ", " << ParentExts[4] << ", " << ParentExts[5] << endl;

// the order is lowI, lowJ, lowK, highI, highJ, highK
    if(my_level < (nLevels -1))
      {
    for (int i = patch+1 ; i < totalPatches ; i++)
      {
      this->myreader->FindLevelAndBlock(i, child_level, child_patch);
      if (my_level+1 != child_level) // only search the patches one level finer
         continue;
      ChildExts[0] = this->myreader->Grids[i].box_corners[0];
      ChildExts[1] = this->myreader->Grids[i].box_corners[1];
      ChildExts[2] = this->myreader->Grids[i].box_corners[2];
      ChildExts[3] = this->myreader->Grids[i].box_corners[3];
      ChildExts[4] = this->myreader->Grids[i].box_corners[4];
      ChildExts[5] = this->myreader->Grids[i].box_corners[5];
      //cerr << i << ":     "<< ChildExts[0] << ", " << ChildExts[1] << ", " << ChildExts[2] << ", " << ChildExts[3] << ", " << ChildExts[4] << ", " << ChildExts[5] << "";

      bool ch_outside_parent =
         (ChildExts[0]  >= ParentExts[3]) ||   // child to right of parent X direction
         (ParentExts[0] >= ChildExts[3] ) ||    // child to the left of parent X direction

         (ChildExts[1]  >= ParentExts[4]) ||   // child above parent Y direction
         (ParentExts[1] >= ChildExts[4] );     // child below parent Y direction

      if(dimension == 3)
         ch_outside_parent = ch_outside_parent || 
         (ChildExts[2]  >= ParentExts[5]) ||
         (ParentExts[2] >= ChildExts[5] );

      if(ch_outside_parent)
        {
        //cerr << " failed\n";
        }
      else
        {
        childPatches.push_back(i);
        //cerr << "child " << i << " passed\n";
        } 
      }
    }
    //cerr <<  "\n";
    ParentExts[0] = this->myreader->Grids[patch].box_corners[0];
    ParentExts[1] = this->myreader->Grids[patch].box_corners[1];
    ParentExts[2] = this->myreader->Grids[patch].box_corners[2];
    ParentExts[3] = this->myreader->Grids[patch].box_corners[3];
    ParentExts[4] = this->myreader->Grids[patch].box_corners[4];
    ParentExts[5] = this->myreader->Grids[patch].box_corners[5];
    dn->SetNestingForDomain(patch, my_level, childPatches, ParentExts);

    int e[6];
    e[0] = ParentExts[0];
    e[1] = ParentExts[1];
    e[2] = ParentExts[2];
    e[3] = ParentExts[3];
    e[4] = (dimension == 2 ? 0 : ParentExts[4]);
    e[5] = (dimension == 2 ? 0 : ParentExts[5]);
    rdb->SetIndicesForAMRPatch(patch, my_level, e);
    }

  void_ref_ptr vr = void_ref_ptr(dn, avtStructuredDomainNesting::Destruct);
  cache->CacheVoidRef("any_mesh", AUXILIARY_DATA_DOMAIN_NESTING_INFORMATION,
                      timestep, -1, vr);
  rdb->CalculateBoundaries();
  void_ref_ptr vrdb;
  if(this->myreader->MappedGrids)
    vrdb = void_ref_ptr(rdb, avtCurvilinearDomainBoundaries::Destruct);
  else
    vrdb = void_ref_ptr(rdb, avtRectilinearDomainBoundaries::Destruct);

  cache->CacheVoidRef("any_mesh", AUXILIARY_DATA_DOMAIN_BOUNDARY_INFORMATION,
                      timestep, -1, vrdb);
}


void
avtAMAZEFileFormat::RegisterDataSelections(
       const std::vector<avtDataSelection_p>& sels,
       std::vector<bool>* applied)
{
  for(size_t i=0; i < sels.size(); ++i)
    {
    if(strcmp(sels[i]->GetType(), "avtResolutionSelection") == 0)
      {
      const avtResolutionSelection* sel =
            static_cast<const avtResolutionSelection*>(*sels[i]);
      this->resolution = sel->resolution();
      (*applied)[i] = true;
      }
    }
}

int
avtAMAZEFileFormat::GetCycleFromFilename(const char *fname) const
{
  const char *ptr;

  if (fname == 0 || fname[0] == '\0')
     return avtFileFormat::INVALID_CYCLE;
  else
    {
     ptr = strstr(fname, "NT=");
     if(ptr)
       return atoi(ptr+3);
     else
       ptr = strstr(fname, "T=0.");
     if(ptr)
       return atoi(ptr+4);
     else
       return 0;
   }
}
